iisnode encountered an error when processing the request.

HRESULT: 0x2
HTTP status: 500
HTTP subStatus: 1002
HTTP reason: Internal Server Error

You are receiving this HTTP 200 response because system.webServer/iisnode/@devErrorsEnabled configuration setting is 'true'.

In addition to the log of stdout and stderr of the node.exe process, consider using debugging and ETW traces to further diagnose the problem.

The node.exe process has not written any information to stderr or iisnode was unable to capture this information. Frequent reason is that the iisnode module is unable to create a log file to capture stdout and stderr output from node.exe. Please check that the identity of the IIS application pool running the node.js application has read and write access permissions to the directory on the server where the node.js application is located. Alternatively you can disable logging by setting system.webServer/iisnode/@loggingEnabled element of web.config to 'false'.



const express = require('express');
const axios = require('axios');
const path = require('path');
const cookieSession = require('cookie-session');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

app.set('trust proxy', true);

// Configurações do OAuth2
const CLIENT_ID = process.env.CLIENT_ID;
const CLIENT_SECRET = process.env.CLIENT_SECRET;
const REDIRECT_URI = process.env.REDIRECT_URI;
const AUTH_BASE_URL = 'https://login.intranet.bb.com.br';
const AUTH_URL = `${AUTH_BASE_URL}/sso/oauth2/authorize`;
const TOKEN_URL = `${AUTH_BASE_URL}/sso/oauth2/access_token`;
const USERINFO_URL = `${AUTH_BASE_URL}/sso/oauth2/userinfo`;

// Configuração de sessão
app.use(
  cookieSession({
    name: 'session',
    keys: ['chave-super-secreta'],
    maxAge: 24 * 60 * 60 * 1000,
    secure: true,
    sameSite: 'lax',
  })
);

// Parse URL-encoded bodies
app.use(express.urlencoded({ extended: true }));

// ===== ROTAS QUE NÃO PRECISAM DE AUTENTICAÇÃO =====

// Callback OAuth2 - DEVE ser acessível sem autenticação
app.get('/auth/callback/bb', async (req, res) => {
  const code = req.query.code;
  const error = req.query.error;
  
  console.log('=== CALLBACK OAUTH2 ===');
  console.log('Code recebido:', code);
  console.log('Error:', error);
  
  if (error) {
    console.error('Erro no callback:', error);
    return res.status(400).send(`Erro de autenticação: ${error}`);
  }
  
  if (!code) {
    console.error('Código de autenticação ausente');
    return res.status(400).send('Código de autenticação ausente.');
  }

  try {
    // Preparar autenticação Basic
    const authHeader = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');
    
    console.log('Trocando code por access_token...');
    console.log('TOKEN_URL:', TOKEN_URL);
    
    // Trocar code por access_token
    const tokenResponse = await axios.post(
      TOKEN_URL,
      new URLSearchParams({
        code: code,
        grant_type: 'authorization_code',
        redirect_uri: REDIRECT_URI,
      }),
      {
        headers: {
          'Authorization': `Basic ${authHeader}`,
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false }),
        timeout: 10000
      }
    );

    console.log('Token response status:', tokenResponse.status);
    console.log('Token response data:', tokenResponse.data);
    
    const accessToken = tokenResponse.data.access_token;

    if (!accessToken) {
      throw new Error('Access token não recebido na resposta');
    }

    // Buscar informações do usuário
    console.log('Buscando informações do usuário...');
    
    const userInfoResponse = await axios.get(USERINFO_URL, {
      headers: { 
        'Authorization': `Bearer ${accessToken}` 
      },
      httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false }),
      timeout: 10000
    });

    console.log('UserInfo response status:', userInfoResponse.status);
    console.log('UserInfo data:', userInfoResponse.data);

    // Salvar na sessão
    req.session.user = userInfoResponse.data;
    req.session.accessToken = accessToken;
    req.session.authenticated = true;

    console.log('=== AUTENTICAÇÃO CONCLUÍDA COM SUCESSO ===');
    console.log('Redirecionando para página principal...');
    
    // Redirecionar para a página principal
    return res.redirect('/');

  } catch (error) {
    console.error('=== ERRO NO CALLBACK OAUTH2 ===');
    console.error('Erro:', error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
      console.error('Response headers:', error.response.headers);
    }
    
    // Limpar sessão em caso de erro
    req.session = null;
    
    return res.status(500).send(`
      <h1>Erro na autenticação OAuth2</h1>
      <p><strong>Erro:</strong> ${error.message}</p>
      <p><strong>Detalhes:</strong> ${error.response?.data ? JSON.stringify(error.response.data) : 'Sem detalhes adicionais'}</p>
      <a href="/">Tentar novamente</a>
    `);
  }
});

// Rota de logout
app.get('/logout', (req, res) => {
  console.log('Logout solicitado');
  req.session = null;
  
  // Endpoint de fim de sessão conforme documentação
  const endSessionUrl = `${AUTH_BASE_URL}/sso/oauth2/connect/endSession`;
  return res.redirect(endSessionUrl);
});

// ===== MIDDLEWARE DE AUTENTICAÇÃO =====
const requireAuth = (req, res, next) => {
  // Verificar se já está autenticado
  if (req.session?.authenticated && req.session?.user) {
    console.log(`Usuário autenticado acessando: ${req.path}`);
    return next();
  }
  
  // Evitar loop infinito - não redirecionar se já estamos indo para auth
  if (req.path === '/auth/callback/bb' || req.path.startsWith('/auth/')) {
    return next();
  }
  
  console.log(`Usuário NÃO autenticado tentando acessar: ${req.path}`);
  console.log('Redirecionando para OAuth2...');
  
  // Construir URL de autorização conforme documentação
  const authParams = new URLSearchParams({
    scope: 'profile email custom', // conforme documentação
    response_type: 'code',
    redirect_uri: REDIRECT_URI,
    client_id: CLIENT_ID
  });
  
  const authUrl = `${AUTH_URL}?${authParams.toString()}`;
  
  console.log('Auth URL:', authUrl);
  
  return res.redirect(authUrl);
};

// ===== APLICAR AUTENTICAÇÃO A TODAS AS ROTAS =====
app.use(requireAuth);

// ===== ROTAS PROTEGIDAS =====

// API para obter dados do usuário
app.get('/api/user', (req, res) => {
  res.json({
    user: req.session.user,
    session: {
      authenticated: req.session.authenticated,
      hasAccessToken: !!req.session.accessToken
    }
  });
});

// Servir arquivos estáticos protegidos
app.use('/dist', express.static(path.join(__dirname, 'dist')));

// Rota principal
app.get('/', (req, res) => {
  console.log(`Servindo página principal para usuário: ${req.session.user?.name || req.session.user?.sub || 'desconhecido'}`);
  
  // Verificar se o arquivo index.html existe
  const indexPath = path.join(__dirname, 'dist', 'index.html');
  
  // Tentar servir o arquivo
  res.sendFile(indexPath, (err) => {
    if (err) {
      console.error('Erro ao servir index.html:', err);
      res.status(500).send(`
        <h1>Erro ao carregar aplicação</h1>
        <p>Não foi possível carregar o arquivo index.html</p>
        <p>Caminho: ${indexPath}</p>
        <p>Erro: ${err.message}</p>
      `);
    }
  });
});

// Catch-all para SPA (deve ser a última rota)
app.get('*', (req, res) => {
  console.log(`Catch-all para: ${req.path}`);
  
  // Verificar se é uma requisição para arquivo que não existe
  if (req.path.includes('.')) {
    console.log(`Arquivo não encontrado: ${req.path}`);
    return res.status(404).send('Arquivo não encontrado');
  }
  
  // Para rotas SPA, servir index.html
  const indexPath = path.join(__dirname, 'dist', 'index.html');
  res.sendFile(indexPath, (err) => {
    if (err) {
      console.error('Erro no catch-all ao servir index.html:', err);
      res.status(500).send('Erro interno do servidor');
    }
  });
});

// Error handler global
app.use((error, req, res, next) => {
  console.error('=== ERRO NÃO TRATADO ===');
  console.error('URL:', req.url);
  console.error('Method:', req.method);
  console.error('Error:', error);
  res.status(500).send('Erro interno do servidor');
});

app.listen(PORT, () => {
  console.log(`=== SERVIDOR INICIADO ===`);
  console.log(`Porta: ${PORT}`);
  console.log(`CLIENT_ID: ${CLIENT_ID}`);
  console.log(`REDIRECT_URI: ${REDIRECT_URI}`);
  console.log(`AUTH_URL: ${AUTH_URL}`);
  console.log(`=========================`);
});



45457854867867867867976987978987987978


<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
    <!-- Configuração do iisnode -->
    <iisnode 
      nodeProcessCommandLine="C:\Program Files\nodejs\node.exe"
      debuggingEnabled="true"
      loggingEnabled="true"
      logDirectory="iisnode"
      interceptor="iisnode/interceptor.js" />
    
    <!-- Handlers -->
    <handlers>
      <add name="iisnode" path="server.js" verb="*" modules="iisnode" />
    </handlers>
    
    <!-- URL Rewrite - TODAS as requisições vão para Node.js -->
    <rewrite>
      <rules>
        <rule name="NodeJS" stopProcessing="true">
          <match url=".*" />
          <action type="Rewrite" url="server.js" />
        </rule>
      </rules>
    </rewrite>
    
    <!-- Documento padrão -->
    <defaultDocument>
      <files>
        <add value="server.js" />
      </files>
    </defaultDocument>
    
    <!-- Configurações de erro -->
    <httpErrors errorMode="Detailed" />
    
    <!-- Headers de segurança -->
    <httpProtocol>
      <customHeaders>
        <add name="X-Frame-Options" value="SAMEORIGIN" />
        <add name="X-Content-Type-Options" value="nosniff" />
      </customHeaders>
    </httpProtocol>
  </system.webServer>
</configuration>
